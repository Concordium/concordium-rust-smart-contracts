use concordium_cis1::*;
use concordium_std::*;

type TokenId = TokenIdU8;
type TokenCount = u8;

#[derive(SchemaType, Serial, DeserialWithState)]
#[concordium(state_parameter = "S")]
struct State<S: HasStateApi> {
    token_state:        StateMap<Address, StateMap<TokenId, TokenCount, S>, S>,
    another_struct:     AnotherStruct<S>,
    total_tokens:       u64,
    boxed_total_tokens: StateBox<u64, S>,
    maybe_box:          MaybeBox<u64, S>,
    #[concordium(size_length = 1)]
    a_string:           String,
}

#[derive(Serial, DeserialWithState)]
#[concordium(state_parameter = "S")]
struct AnotherStruct<S> {
    a_set: StateSet<u8, S>,
}

#[derive(Serial, DeserialWithState)]
#[concordium(state_parameter = "MBS")]
enum MaybeBox<S: Serialize, MBS: HasStateApi> {
    NoBox(S),
    WithBox(StateBox<String, MBS>),
}

#[init(contract = "storable-contract")]
fn init<S: HasStateApi>(
    _ctx: &impl HasInitContext,
    state_builder: &mut StateBuilder<S>,
) -> InitResult<State<S>> {
    Ok(State {
        token_state:        state_builder.new_map(),
        another_struct:     AnotherStruct {
            a_set: state_builder.new_set(),
        },
        total_tokens:       0,
        boxed_total_tokens: state_builder.new_box(0u64),
        maybe_box:          MaybeBox::NoBox(0),
        a_string:           "hello".into(),
    })
}

#[derive(Serialize, SchemaType)]
struct MintParams {
    owner:       Address,
    token_id:    TokenId,
    token_count: TokenCount,
}

#[receive(contract = "storable-contract", name = "mint", parameter = "MintParams", mutable)]
fn receive_mint<S: HasStateApi>(
    ctx: &impl HasReceiveContext,
    host: &mut impl HasHost<State<S>, StateApiType = S>,
) -> ReceiveResult<()> {
    let params: MintParams = ctx.parameter_cursor().get()?;

    let (state, builder) = host.state_and_builder();
    let mut owner_map = state.token_state.entry(params.owner).or_insert_with(|| builder.new_map());
    let mut token_count = owner_map.entry(params.token_id).or_insert(0);
    *token_count += params.token_count;

    state.another_struct.a_set.insert(42);

    state.maybe_box = MaybeBox::WithBox(builder.new_box("I'm boxed".into()));

    // This won't be persisted. The change only occurs in memory.
    state.total_tokens += params.token_count as u64;

    // But this should be.
    state.boxed_total_tokens.update(|old_count| *old_count += params.token_count as u64);

    Ok(())
}

#[receive(contract = "storable-contract", name = "readonly")]
fn receive_readonly<S: HasStateApi>(
    _ctx: &impl HasReceiveContext,
    host: &impl HasHost<State<S>, StateApiType = S>,
) -> ReceiveResult<u64> {
    Ok(*host.state().boxed_total_tokens.get())
}

#[concordium_cfg_test]
mod tests {
    use super::*;
    use test_infrastructure::*;

    #[concordium_test]
    fn test_init() {
        let ctx = TestInitContext::empty();

        let mut state_builder = TestStateBuilder::new();

        let _state = init(&ctx, &mut state_builder).expect("Init failed");
    }

    #[concordium_test]
    fn test_receive() {
        let mut ctx = TestReceiveContext::empty();
        let owner = Address::Account(AccountAddress([0u8; 32]));
        let token_id = TokenIdU8(10);
        let expected_token_count = 100;
        let parameter_bytes = to_bytes(&MintParams {
            owner,
            token_id,
            token_count: expected_token_count,
        });
        ctx.set_parameter(&parameter_bytes);

        let mut state_api = TestStateApi::new();
        let mut state_builder = TestStateBuilder::open(state_api.clone());

        // TODO: These extra serial/deserial state steps are no longer necessary. But we
        // can keep them for now to ensure that everything works as expected.

        // Set up initial state contents via init.
        let state_to_store =
            init(&TestInitContext::empty(), &mut state_builder).expect("Init failed");

        // This store invocation normally occurs in the code generated by the init
        // macro.
        let mut root_entry = state_api.create(&[]).expect("Creating root entry failed");
        state_to_store.serial(&mut root_entry).expect("Writing state failed");

        // Then load the state, as it happens when calling receive.
        root_entry.seek(SeekFrom::Start(0)).expect("Seeking to start failed");
        let state_for_rcv =
            State::deserial_with_state(&state_api, &mut root_entry).expect("Could not read state");

        let mut host = TestHost::new(state_for_rcv, state_builder);

        // Invoke receive.
        assert!(receive_mint(&ctx, &mut host).is_ok());

        // Store the state, as it normally occurs with the receive.
        root_entry.seek(SeekFrom::Start(0)).expect("Seeking to start failed");
        host.state().serial(&mut root_entry).expect("Could not serial state");

        // Reload the state to ensure that it was actually persisted (and not just
        // altered in memory).
        root_entry.seek(SeekFrom::Start(0)).expect("Seeking to start failed");
        let state_reloaded = State::deserial_with_state(&state_api, &mut root_entry)
            .expect("Could not load all of state.");

        // Token count should be 100.
        assert_eq!(
            *state_reloaded.token_state.get(&owner).unwrap().get(&token_id).unwrap(),
            expected_token_count
        );

        let mut a_set_iter = state_reloaded.another_struct.a_set.iter();
        assert_eq!(*a_set_iter.next().expect("Should exist"), 42);
        assert!(a_set_iter.next().is_none());

        assert_eq!(state_reloaded.total_tokens, 100);
        assert_eq!(*state_reloaded.boxed_total_tokens.get(), 100);

        assert_eq!(state_reloaded.maybe_box.get_box_contents(), Some("I'm boxed".into()))
    }

    impl<A, S> MaybeBox<A, S>
    where
        S: HasStateApi,
        A: Serialize,
    {
        fn get_box_contents(&self) -> Option<String> {
            match self {
                MaybeBox::NoBox(_) => None,
                MaybeBox::WithBox(the_box) => Some(the_box.get().clone()),
            }
        }
    }
}
